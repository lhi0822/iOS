//
//  ViewController.m
//  mfinity-consumer
//
//  Created by Jun HyungPark on 2015. 6. 5..
//  Copyright (c) 2015년 DBValley. All rights reserved.
//

#import "IntroViewController.h"
#import "SVProgressHUD.h"
#import "WebViewController.h"
#import "NSData+AES.h"
#import "ZipArchive.h"
#import "AppDelegate.h"
#import <CommonCrypto/CommonCryptor.h>
@interface IntroViewController (){
    NSMutableData *receiveData;
    NSString *aeskey;
}

@end

@implementation IntroViewController


#pragma mark
#pragma mark - Life Cycle

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    self.navigationController.navigationBarHidden = YES;
    aeskey = @"E3Z2S1M5A9R8T1F3E2E4L31504081532";
    
    if (@available(iOS 13.0, *)) {
        [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleDarkContent;
    } else {
        // Fallback on earlier versions
    }
    
    [self storeVersionCheck];
    //[self callMenu];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

#pragma mark
#pragma mark - Util Method
-(void)storeVersionCheck{
    NSDictionary* infoDictionary = [[NSBundle mainBundle] infoDictionary];
    NSString* appID = infoDictionary[@"CFBundleIdentifier"];
    
    NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"http://itunes.apple.com/kr/lookup?bundleId=%@", appID]];
    NSData *data = [NSData dataWithContentsOfURL:url];
    NSDictionary *lookup = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];
    
    if ([lookup[@"resultCount"] integerValue] == 1){
        @try{
            NSString *appStoreVersion = lookup[@"results"][0][@"version"];
            NSString *currentVersion = infoDictionary[@"CFBundleShortVersionString"];
            
            appStoreVersion = [appStoreVersion stringByReplacingOccurrencesOfString:@"." withString:@""];
            currentVersion = [currentVersion stringByReplacingOccurrencesOfString:@"." withString:@""];
            
            int storeVer = [appStoreVersion intValue];
            int currentVer = [currentVersion intValue];
            
            NSLog(@"store : %d, curr ; %d", storeVer, currentVer);
            
            if(storeVer>currentVer){
            //if([NSString stringWithFormat:@"%d", storeVer]>[NSString stringWithFormat:@"%d", currentVer]){
                NSLog(@"업데이트 O");
                UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"업데이트 알림"
                                                                               message:@"새로운 업데이트가 있습니다. \n지금 업데이트 하시겠습니까?"
                                                                        preferredStyle:UIAlertControllerStyleAlert];
                UIAlertAction *okButton = [UIAlertAction actionWithTitle:@"업데이트" style:UIAlertActionStyleDefault
                                                                 handler:^(UIAlertAction * action) {
                                                                     NSString *storeUrl = @"https://apps.apple.com/kr/app/%EA%B2%BD%EB%8F%99%EB%8F%84%EC%8B%9C%EA%B0%80%EC%8A%A4-%EC%8A%A4%EB%A7%88%ED%8A%B8%EA%B3%A0%EA%B0%9D%EC%A7%80%EC%9B%90/id1021730140";
                                                                     [[UIApplication sharedApplication]openURL:[NSURL URLWithString:storeUrl] options:@{} completionHandler:nil];
                                                                     
                                                                     [alert dismissViewControllerAnimated:YES completion:nil];
                                                                 }];
                [alert addAction:okButton];
                [self presentViewController:alert animated:YES completion:nil];
                
                
            } else if(storeVer==currentVer){//else if([NSString stringWithFormat:@"%d", storeVer]==[NSString stringWithFormat:@"%d", currentVer]){
                NSLog(@"업데이트 X");
                [self callMenu];
                
            } else{
                NSLog(@"다운그레이드");
                [self callMenu];
            }
            
        } @catch(NSException *e){
            [self callMenu];
        }
    }
}

-(void)callMenu{
    // 테스트 URL
    //NSURL *url = [NSURL URLWithString:@"http://ezpro1.mfrontiers.com:1598/dataservice41/KDCMenu"];
    //NSString *paramString = @"appNo=2";
    
    // 서비스 URL
    NSURL *url = [NSURL URLWithString:@"https://app.kdgas.co.kr/dataservice41/KDCMenu"];
    NSString *paramString = @"appNo=3";
    
    NSData *postData = [paramString dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
    NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url];
    [request setHTTPMethod:@"POST"];
    [request setHTTPBody:postData];
    [request setTimeoutInterval:10.f];
    
    NSURLConnection * conn = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO];
    if (conn!=nil) {
        NSLog(@"conn is not null");
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
        //[SVProgressHUD show];
        [SVProgressHUD showWithStatus:@"다운로드중입니다."];
        receiveData = [[NSMutableData alloc]init];
        [conn start];
    }
}
- (void)saveFileDownloadURL:(NSString *)downloadURL webAppPath:(NSString *)webAppPath appNo:(NSString *)appNo webAppVer:(NSString *)webAppVer{
    NSFileManager *manager = [NSFileManager defaultManager];
    NSError *error;
    NSData *webapp = [[NSData alloc]initWithContentsOfURL:[NSURL URLWithString:downloadURL]];
    
    NSLog(@"mkdir 1: %d",[manager createDirectoryAtPath:webAppPath withIntermediateDirectories:NO attributes:nil error:&error]);
    webAppPath = [webAppPath stringByAppendingPathComponent:appNo];
    NSLog(@"mkdir 2: %d",[manager createDirectoryAtPath:webAppPath withIntermediateDirectories:NO attributes:nil error:&error]);
    NSString *webAppFile = [webAppPath stringByAppendingPathComponent:@"webapp.zip"];
    NSLog(@"mkdir error : %@",error);
    NSLog(@"write file : %d",[webapp writeToFile:webAppFile atomically:YES]);
    
    ZipArchive *zip = [[ZipArchive alloc]init];
    if ([zip UnzipOpenFile:webAppFile]) {
        [zip UnzipFileTo:webAppPath overWrite:YES];
    }
    [zip UnzipCloseFile];
    NSLog(@"dir files : %@",[manager contentsOfDirectoryAtPath:webAppPath error:&error]);
    [manager removeItemAtPath:webAppFile error:nil];
    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
    [SVProgressHUD dismiss];
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    [prefs setObject:webAppVer forKey:@"WEBAPP_VER"];
    [prefs synchronize];
}
#pragma mark
#pragma mark - NSURLConnectionDataDelegate
-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error{
    NSLog(@"KDCMenu error : %@",error);
    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
    [SVProgressHUD dismiss];
    UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@"네트워크 오류" message:[error localizedDescription]  delegate:self cancelButtonTitle:@"취소" otherButtonTitles:@"재시도",nil];
    [alertView show];
}
-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response{
    NSHTTPURLResponse *HTTPresponse = (NSHTTPURLResponse *)response;
    NSInteger statusCode = [HTTPresponse statusCode];
    NSString *urlStr = connection.currentRequest.URL.absoluteString;
    NSArray *tempArr = [[urlStr lastPathComponent] componentsSeparatedByString:@"?"];
    NSString *methodName = [tempArr objectAtIndex:0];
    
    if ([methodName isEqualToString:@"MLogout"]) {
        exit(0);
    }else{
        if(statusCode == 404 || statusCode == 500){
            [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
            [SVProgressHUD dismiss];
            [connection cancel];
            UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@"네트워크 오류" message:@"내부 서버 오류 입니다.\n관리자에게 문의하세요." delegate:self cancelButtonTitle:@"확인" otherButtonTitles: nil];
            [alertView show];
        }
    }
}
-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data{
    [receiveData appendData:data];
}
-(void)connectionDidFinishLoading:(NSURLConnection *)connection{
    AppDelegate *appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;
    NSFileManager *manager = [NSFileManager defaultManager];
    NSString *urlStr = connection.currentRequest.URL.absoluteString;
    NSArray *tempArr = [[urlStr lastPathComponent] componentsSeparatedByString:@"?"];
    NSString *methodName = [tempArr objectAtIndex:0];
    
    if ([methodName isEqualToString:@"KDCPushIdUpdate"]) {
        NSLog(@"[ KDCPushIdUpdate ]");
        NSString *webAppPath = @"";
        NSString *documentPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
        NSString *userPath = [documentPath stringByAppendingPathComponent:[_resultDic objectForKey:@"V2"]];
        appDelegate.user_no= [_resultDic objectForKey:@"V2"];       //user No.

        [manager createDirectoryAtPath:userPath withIntermediateDirectories:NO attributes:nil error:nil];
        NSString *appNo = [_resultDic objectForKey:@"V3"];         // webapp No.
        NSString *webappVer = [_resultDic objectForKey:@"V12"];    // webapp version
        NSString *downloadURL = [_resultDic objectForKey:@"V13"];  // webapp downlaod url
        NSString *startHTML = [_resultDic objectForKey:@"V6"];     // start html
        appDelegate.menuNo = appNo;
        startHTML = (__bridge_transfer NSString *)CFURLCreateStringByReplacingPercentEscapesUsingEncoding(NULL, (CFStringRef)startHTML, CFSTR(""), kCFStringEncodingUTF8);
        NSLog(@"downloadURL : %@",downloadURL);
        
        NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
        webAppPath = [documentPath stringByAppendingPathComponent:@"webapp"];
        NSString *tmpPath = [webAppPath stringByAppendingPathComponent:appNo];
        tmpPath = [tmpPath stringByAppendingString:startHTML];
        if ([[prefs objectForKey:@"WEBAPP_VER"] isEqualToString:webappVer]) {
            if ([manager isReadableFileAtPath:tmpPath]) {
                [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
                [SVProgressHUD dismiss];
                
            }else{
                [self saveFileDownloadURL:downloadURL webAppPath:webAppPath appNo:appNo webAppVer:webappVer];
            }
        }else{
            [self saveFileDownloadURL:downloadURL webAppPath:webAppPath appNo:appNo webAppVer:webappVer];
            
        }
        webAppPath = [webAppPath stringByAppendingPathComponent:appNo];
        
        WebViewController *vc = (WebViewController *)[self.storyboard instantiateViewControllerWithIdentifier:@"WebViewController"];
        vc.baseURL = [webAppPath stringByAppendingString:@"/contents/dmain/html/"];
        vc.startURL = [webAppPath stringByAppendingPathComponent:startHTML];
        NSLog(@"vc.BaseURL : %@",vc.baseURL);
        NSLog(@"vc.StartURL : %@",vc.startURL);
        
        [self.navigationController pushViewController:vc animated:YES];
//        vc.modalPresentationStyle = UIModalPresentationFullScreen;
//        [self presentViewController:vc animated:YES completion:nil];
        
    }else{
        NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
        if([prefs objectForKey:@"FCM_TOKEN"]==nil || ![appDelegate.fcmToken isEqualToString:[prefs objectForKey:@"FCM_TOKEN"]]){
            NSLog(@"FCM 키가 없거나 다름 ! \nappDelegate.fcmToken : %@ \nFCM_TOKEN : %@", appDelegate.fcmToken, [prefs objectForKey:@"FCM_TOKEN"]);
            [prefs setObject:appDelegate.fcmToken forKey:@"FCM_TOKEN"];
            [prefs synchronize];

//            NSString *urlString = [[NSString alloc] initWithFormat:@"%@/KDCPushIdUpdate",appDelegate.main_url];
//            NSString *paramString = [[NSString alloc]initWithFormat:@"dvcid=%@&pushid1=%@&pushid2=-",[AppDelegate getUUID], appDelegate.fcmToken];
//            NSData *paramData = [paramString dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
//
//            NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:[NSURL URLWithString:urlString]];
//            [request setHTTPMethod:@"POST"];
//            [request setHTTPBody: paramData];
//            [request setTimeoutInterval:10.0];
//            NSURLConnection *urlCon = [[NSURLConnection alloc] initWithRequest:request delegate:self];
//            if (urlCon) {
//                receiveData = [[NSMutableData alloc]init];
//            }else{
//                [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:FALSE];
//            }
        }
        
        NSString *encString = [[NSString alloc]initWithData:receiveData encoding:NSUTF8StringEncoding];
        NSError *error;
        NSString *decString = [encString AES256DecryptWithKeyString:aeskey];
        NSDictionary *tmpDic = [NSJSONSerialization JSONObjectWithData:[decString dataUsingEncoding:NSUTF8StringEncoding] options:kNilOptions error:&error];
        NSDictionary *dic = [tmpDic objectForKey:@"0"];
        NSLog(@"dic : %@",dic);
        dic = [AppDelegate getAllValueUrlDecoding:dic];
        _resultDic = [NSDictionary dictionaryWithDictionary:dic];
        
        NSString *webService = [dic objectForKey:@"V18"];   // push Info. webservice
        NSLog(@"webService : %@",webService);
        
        //201125 서버업데이트 전이라 apns푸시 사용
        if (![webService isEqualToString:@"#"]) {
            NSURL *url = [NSURL URLWithString:webService];
            NSString *dvcID = [AppDelegate getUUID];
            NSString *paramString = [NSString stringWithFormat:@"devid=%@&pushid1=%@&pushid2=-&devos=iPhone OS",dvcID,appDelegate.pushToken];
//            NSString *paramString = [NSString stringWithFormat:@"devid=%@&pushid1=%@&pushid2=-&devos=iPhone OS",dvcID,appDelegate.fcmToken];
  
            NSData *postData = [paramString dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
            NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url];
            [request setHTTPMethod:@"POST"];
            [request setHTTPBody:postData];
            [request setTimeoutInterval:10.f];
            
            NSURLConnection * conn = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO];
            if (conn!=nil) {
                NSLog(@"conn is not null");
                [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
                //[SVProgressHUD show];
                //[SVProgressHUD showWithStatus:@"다운로드중입니다."];
                receiveData = [[NSMutableData alloc]init];
                [conn start];
            }

        }
        

    }
    
}

#pragma mark
#pragma mark - UIAlertViewDelegate
-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{
    if ([alertView.title isEqualToString:@"네트워크 오류"]) {
        if (buttonIndex==1) {
            [self callMenu];
        }else{
            WebViewController *vc = (WebViewController *)[self.storyboard instantiateViewControllerWithIdentifier:@"WebViewController"];
            [self.navigationController pushViewController:vc animated:YES];
            
        }
        
    }
}

#pragma mark


@end

@implementation NSString (URLEncoding)

- (NSString *)urlEncodeUsingEncoding:(NSStringEncoding)encoding{
    return (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(NULL, (CFStringRef)self, NULL, (CFStringRef)@"!*'\"();:@&=+$,/?%#[]% ", CFStringConvertNSStringEncodingToEncoding(encoding)));
}
+ (NSString *)urlDecodeString:(NSString *)str
{
    NSString *temp = [str stringByReplacingOccurrencesOfString:@"+" withString:@"%20"];
    NSString *result = (NSString *)CFBridgingRelease(CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault,
                                                                                                             (CFStringRef)temp,
                                                                                                             CFSTR(""),
                                                                                                             kCFStringEncodingUTF8));
    return result;
}
- (NSString *)AES256EncryptWithKeyString:(NSString *)key
{
    NSData *plainData = [self dataUsingEncoding:NSUTF8StringEncoding];
    NSData *encryptedData = [plainData AES256EncryptWithKey:key];
    
    NSString *encryptedString = [encryptedData base64Encoding];
    //[encryptedData base64EncodedDataWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
    return encryptedString;
}

- (NSString *)AES256DecryptWithKeyString:(NSString *)key
{
    NSData *encryptedData = [NSData dataWithBase64EncodedString:self];
    NSData *plainData = [encryptedData AES256DecryptWithKey:key];
    
    NSString *plainString = [[NSString alloc] initWithData:plainData encoding:NSUTF8StringEncoding];
    
    return plainString;
}
- (NSString *) URLEncode{
    return [self stringByAddingPercentEscapesUsingEncoding:NSASCIIStringEncoding];
}
@end
@implementation NSData(NSDataSeed)
+ (NSData *) dataWithBase64EncodedString:(NSString *) string {
    return [[NSData allocWithZone:nil] initWithBase64EncodedString:string];
}

- (id) initWithBase64EncodedString:(NSString *) string {
    NSMutableData *mutableData = nil;
    
    if( string ) {
        unsigned long ixtext = 0;
        unsigned long lentext = 0;
        unsigned char ch = 0;
        unsigned char inbuf[4], outbuf[3];
        short i = 0, ixinbuf = 0;
        BOOL flignore = NO;
        BOOL flendtext = NO;
        NSData *base64Data = nil;
        const unsigned char *base64Bytes = nil;
        
        // Convert the string to ASCII data.
        base64Data = [string dataUsingEncoding:NSASCIIStringEncoding];
        base64Bytes = [base64Data bytes];
        mutableData = [NSMutableData dataWithCapacity:[base64Data length]];
        lentext = [base64Data length];
        
        while( YES ) {
            if( ixtext >= lentext ) break;
            ch = base64Bytes[ixtext++];
            flignore = NO;
            
            if( ( ch >= 'A' ) && ( ch <= 'Z' ) ) ch = ch - 'A';
            else if( ( ch >= 'a' ) && ( ch <= 'z' ) ) ch = ch - 'a' + 26;
            else if( ( ch >= '0' ) && ( ch <= '9' ) ) ch = ch - '0' + 52;
            else if( ch == '+' ) ch = 62;
            else if( ch == '=' ) flendtext = YES;
            else if( ch == '/' ) ch = 63;
            else flignore = YES;
            
            if( ! flignore ) {
                short ctcharsinbuf = 3;
                BOOL flbreak = NO;
                
                if( flendtext ) {
                    if( ! ixinbuf ) break;
                    if( ( ixinbuf == 1 ) || ( ixinbuf == 2 ) ) ctcharsinbuf = 1;
                    else ctcharsinbuf = 2;
                    ixinbuf = 3;
                    flbreak = YES;
                }
                
                inbuf [ixinbuf++] = ch;
                
                if( ixinbuf == 4 ) {
                    ixinbuf = 0;
                    outbuf [0] = ( inbuf[0] << 2 ) | ( ( inbuf[1] & 0x30) >> 4 );
                    outbuf [1] = ( ( inbuf[1] & 0x0F ) << 4 ) | ( ( inbuf[2] & 0x3C ) >> 2 );
                    outbuf [2] = ( ( inbuf[2] & 0x03 ) << 6 ) | ( inbuf[3] & 0x3F );
                    
                    for( i = 0; i < ctcharsinbuf; i++ )
                        [mutableData appendBytes:&outbuf[i] length:1];
                }
                
                if( flbreak )  break;
            }
        }
    }
    
    self = [self initWithData:mutableData];
    return self;
}
@end
